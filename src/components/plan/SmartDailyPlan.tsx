/**
 * SmartDailyPlan Component
 *
 * AI-powered daily plan component that displays focus blocks, quick wins,
 * meetings, and defer suggestions generated by the AI.
 *
 * Requirements: 1.6, 1.7, 5.1, 5.5, 6.4, 8.4, 8.5
 */

import { useState, useEffect } from "react";
import { useDailyPlan } from "../../hooks/useDailyPlan";
import { CachedBadge } from "../offline";
import { REGENERATE_PLAN_EVENT } from "../../hooks/useKeyboardShortcuts";
import type { PlanTask, ItemFeedbackType } from "../../services/backend/plan";
import "./DailyPlan.css";

interface SmartDailyPlanProps {
  onTaskComplete?: (taskId: string) => void;
  onTaskCreate?: (title: string) => void;
}

export function SmartDailyPlan({
  onTaskComplete,
  // onTaskCreate is available for future use when QuickTaskInput is integrated
  onTaskCreate: _onTaskCreate,
}: SmartDailyPlanProps) {
  void _onTaskCreate; // Suppress unused variable warning
  const { plan, isLoading, isGenerating, error, regenerate, submitItemFeedback, isStale, cachedAt } = useDailyPlan();

  // Listen for keyboard shortcut to regenerate plan (Cmd+R)
  useEffect(() => {
    const handleRegenerate = () => {
      if (!isGenerating) {
        regenerate();
      }
    };

    window.addEventListener(REGENERATE_PLAN_EVENT, handleRegenerate);
    return () => window.removeEventListener(REGENERATE_PLAN_EVENT, handleRegenerate);
  }, [regenerate, isGenerating]);

  const getGreeting = () => {
    const hour = new Date().getHours();
    if (hour < 12) return "Good morning";
    if (hour < 18) return "Good afternoon";
    return "Good evening";
  };

  const formatSuggestedTime = (time?: string) => {
    if (!time) return null;
    try {
      const date = new Date(time);
      return date.toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      });
    } catch {
      return time;
    }
  };

  const getPriorityColor = (priority: PlanTask["priority"]) => {
    switch (priority) {
      case "high":
        return "var(--color-error, #ef4444)";
      case "medium":
        return "var(--color-warning, #f59e0b)";
      case "low":
        return "var(--color-success, #22c55e)";
      default:
        return "var(--color-text-secondary)";
    }
  };

  const getTypeIcon = (type: PlanTask["type"]) => {
    switch (type) {
      case "focus":
        return "üéØ";
      case "task":
        return "‚úÖ";
      case "email":
        return "üìß";
      case "meeting":
        return "üìÖ";
      case "break":
        return "‚òï";
      default:
        return "üìã";
    }
  };

  if (isLoading) {
    return (
      <div className="daily-plan loading">
        <div className="loading-spinner" />
        <p>Loading your AI-powered plan...</p>
      </div>
    );
  }

  if (error && !plan) {
    return (
      <div className="daily-plan error">
        <p>{error}</p>
        <button onClick={regenerate}>Generate Plan</button>
      </div>
    );
  }

  return (
    <div className="daily-plan">
      <header className="plan-header titlebar-drag-region">
        <div className="greeting no-drag">
          <h1>{getGreeting()}</h1>
          <p className="date">
            {new Date().toLocaleDateString("en-US", {
              weekday: "long",
              month: "long",
              day: "numeric",
            })}
            {isStale && <CachedBadge isStale={isStale} cachedAt={cachedAt} className="plan-cached-badge" />}
          </p>
        </div>
        <button
          className="refresh-btn no-drag"
          onClick={regenerate}
          disabled={isGenerating}
          title={isGenerating ? "Generating..." : "Regenerate plan"}
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            className={isGenerating ? "spinning" : ""}
          >
            <path d="M21 12a9 9 0 11-2.2-5.9M21 4v4h-4" />
          </svg>
        </button>
      </header>

      <main className="plan-content">
        {/* Summary and Energy Tip */}
        {plan && (plan.summary || plan.energy_tip) && (
          <section className="plan-block glass summary-block">
            {plan.summary && (
              <p className="plan-summary">{plan.summary}</p>
            )}
            {plan.energy_tip && (
              <p className="energy-tip">
                <span className="tip-icon">üí°</span>
                {plan.energy_tip}
              </p>
            )}
          </section>
        )}

        {/* Focus Blocks */}
        <section className="plan-block glass">
          <h2 className="block-title">
            <span className="block-icon">üéØ</span>
            Focus Blocks
          </h2>
          {!plan || plan.focus_blocks.length === 0 ? (
            <p className="empty-state">No focus blocks scheduled</p>
          ) : (
            <ul className="task-list">
              {plan.focus_blocks.map((task) => (
                <PlanTaskItem
                  key={task.id}
                  task={task}
                  itemType="focus_block"
                  onComplete={onTaskComplete}
                  onFeedback={submitItemFeedback}
                  formatTime={formatSuggestedTime}
                  getPriorityColor={getPriorityColor}
                  getTypeIcon={getTypeIcon}
                />
              ))}
            </ul>
          )}
        </section>

        {/* Quick Wins */}
        <section className="plan-block glass">
          <h2 className="block-title">
            <span className="block-icon">‚ö°</span>
            Quick Wins
          </h2>
          {!plan || plan.quick_wins.length === 0 ? (
            <p className="empty-state">No quick wins available</p>
          ) : (
            <ul className="task-list">
              {plan.quick_wins.map((task) => (
                <PlanTaskItem
                  key={task.id}
                  task={task}
                  itemType="quick_win"
                  onComplete={onTaskComplete}
                  onFeedback={submitItemFeedback}
                  formatTime={formatSuggestedTime}
                  getPriorityColor={getPriorityColor}
                  getTypeIcon={getTypeIcon}
                />
              ))}
            </ul>
          )}
        </section>

        {/* Meetings */}
        <section className="plan-block glass">
          <h2 className="block-title">
            <span className="block-icon">üìÖ</span>
            Meetings
          </h2>
          {!plan || plan.meetings.length === 0 ? (
            <p className="empty-state">No meetings scheduled</p>
          ) : (
            <ul className="event-list">
              {plan.meetings.map((meeting) => (
                <MeetingItem
                  key={meeting.id}
                  meeting={meeting}
                  onFeedback={submitItemFeedback}
                  formatTime={formatSuggestedTime}
                />
              ))}
            </ul>
          )}
        </section>

        {/* Defer Suggestions */}
        {plan && plan.defer_suggestions.length > 0 && (
          <section className="plan-block glass defer-block">
            <h2 className="block-title">
              <span className="block-icon">üìå</span>
              Consider Deferring
            </h2>
            <ul className="defer-list">
              {plan.defer_suggestions.map((suggestion, index) => (
                <DeferItem
                  key={index}
                  suggestion={suggestion}
                  index={index}
                  onFeedback={submitItemFeedback}
                />
              ))}
            </ul>
          </section>
        )}

        {/* No Plan State */}
        {!plan && !error && (
          <section className="plan-block glass">
            <div className="no-plan-state">
              <p>No plan generated yet for today.</p>
              <button
                className="generate-btn"
                onClick={regenerate}
                disabled={isGenerating}
              >
                {isGenerating ? "Generating..." : "Generate AI Plan"}
              </button>
            </div>
          </section>
        )}
      </main>
    </div>
  );
}


/**
 * Individual plan task item component
 */
interface PlanTaskItemProps {
  task: PlanTask;
  itemType: "focus_block" | "quick_win" | "meeting" | "defer";
  onComplete?: (taskId: string) => void;
  onFeedback?: (
    itemId: string,
    itemTitle: string,
    feedbackType: ItemFeedbackType,
    itemType: "focus_block" | "quick_win" | "meeting" | "defer"
  ) => Promise<boolean>;
  formatTime: (time?: string) => string | null;
  getPriorityColor: (priority: PlanTask["priority"]) => string;
  getTypeIcon: (type: PlanTask["type"]) => string;
}

function PlanTaskItem({
  task,
  itemType,
  onComplete,
  onFeedback,
  formatTime,
  getPriorityColor,
  getTypeIcon,
}: PlanTaskItemProps) {
  const [feedbackGiven, setFeedbackGiven] = useState<ItemFeedbackType | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleComplete = () => {
    if (task.source_id && onComplete) {
      onComplete(task.source_id);
    }
  };

  const handleFeedback = async (type: ItemFeedbackType) => {
    if (!onFeedback || isSubmitting) return;
    
    setIsSubmitting(true);
    const success = await onFeedback(task.id, task.title, type, itemType);
    if (success) {
      setFeedbackGiven(type);
    }
    setIsSubmitting(false);
  };

  return (
    <li className="task-item plan-task-item">
      {task.source_type === "task" && (
        <input
          type="checkbox"
          className="task-checkbox"
          onChange={handleComplete}
          title="Mark as complete"
        />
      )}
      <div className="task-content">
        <div className="task-header">
          <span className="task-type-icon">{getTypeIcon(task.type)}</span>
          <span className="task-title">{task.title}</span>
          <span
            className="task-priority"
            style={{ color: getPriorityColor(task.priority) }}
          >
            {task.priority}
          </span>
        </div>
        <div className="task-meta">
          {task.suggested_time && (
            <span className="suggested-time">
              üïê {formatTime(task.suggested_time)}
            </span>
          )}
          {task.duration_minutes > 0 && (
            <span className="task-duration">
              ‚è±Ô∏è {task.duration_minutes}min
            </span>
          )}
        </div>
        {task.context && (
          <p className="task-context">{task.context}</p>
        )}
      </div>
      <FeedbackButtons
        feedbackGiven={feedbackGiven}
        isSubmitting={isSubmitting}
        onFeedback={handleFeedback}
      />
    </li>
  );
}

/**
 * Meeting item component
 */
interface MeetingItemProps {
  meeting: PlanTask;
  onFeedback?: (
    itemId: string,
    itemTitle: string,
    feedbackType: ItemFeedbackType,
    itemType: "focus_block" | "quick_win" | "meeting" | "defer"
  ) => Promise<boolean>;
  formatTime: (time?: string) => string | null;
}

function MeetingItem({ meeting, onFeedback, formatTime }: MeetingItemProps) {
  const [feedbackGiven, setFeedbackGiven] = useState<ItemFeedbackType | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const isStartingSoon = () => {
    if (!meeting.suggested_time) return false;
    try {
      const meetingTime = new Date(meeting.suggested_time);
      const now = new Date();
      const diffMinutes = (meetingTime.getTime() - now.getTime()) / (1000 * 60);
      return diffMinutes >= 0 && diffMinutes <= 15;
    } catch {
      return false;
    }
  };

  const handleFeedback = async (type: ItemFeedbackType) => {
    if (!onFeedback || isSubmitting) return;
    
    setIsSubmitting(true);
    const success = await onFeedback(meeting.id, meeting.title, type, "meeting");
    if (success) {
      setFeedbackGiven(type);
    }
    setIsSubmitting(false);
  };

  return (
    <li className={`event-item ${isStartingSoon() ? "starting-soon" : ""}`}>
      <div className="event-time">
        {formatTime(meeting.suggested_time) || "TBD"}
      </div>
      <div className="event-details">
        <span className="event-title">{meeting.title}</span>
        {meeting.duration_minutes > 0 && (
          <span className="event-duration">
            {meeting.duration_minutes} minutes
          </span>
        )}
        {meeting.context && (
          <span className="event-location">{meeting.context}</span>
        )}
      </div>
      <FeedbackButtons
        feedbackGiven={feedbackGiven}
        isSubmitting={isSubmitting}
        onFeedback={handleFeedback}
      />
    </li>
  );
}

/**
 * Defer suggestion item component
 */
interface DeferItemProps {
  suggestion: string | PlanTask;
  index: number;
  onFeedback?: (
    itemId: string,
    itemTitle: string,
    feedbackType: ItemFeedbackType,
    itemType: "focus_block" | "quick_win" | "meeting" | "defer"
  ) => Promise<boolean>;
}

function DeferItem({ suggestion, index, onFeedback }: DeferItemProps) {
  const [feedbackGiven, setFeedbackGiven] = useState<ItemFeedbackType | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Handle both string and PlanTask types
  const suggestionText = typeof suggestion === "string" ? suggestion : suggestion.title;
  const suggestionId = typeof suggestion === "string" ? `defer-${index}` : suggestion.id;

  const handleFeedback = async (type: ItemFeedbackType) => {
    if (!onFeedback || isSubmitting) return;
    
    setIsSubmitting(true);
    const success = await onFeedback(suggestionId, suggestionText, type, "defer");
    if (success) {
      setFeedbackGiven(type);
    }
    setIsSubmitting(false);
  };

  return (
    <li className="defer-item">
      <span className="defer-text">{suggestionText}</span>
      <FeedbackButtons
        feedbackGiven={feedbackGiven}
        isSubmitting={isSubmitting}
        onFeedback={handleFeedback}
      />
    </li>
  );
}

/**
 * Feedback buttons component (thumbs up/down)
 * Requirements: 5.5
 */
interface FeedbackButtonsProps {
  feedbackGiven: ItemFeedbackType | null;
  isSubmitting: boolean;
  onFeedback: (type: ItemFeedbackType) => void;
}

function FeedbackButtons({ feedbackGiven, isSubmitting, onFeedback }: FeedbackButtonsProps) {
  return (
    <div className="feedback-buttons">
      <button
        className={`feedback-btn thumbs-up ${feedbackGiven === "positive" ? "active" : ""}`}
        onClick={() => onFeedback("positive")}
        disabled={isSubmitting || feedbackGiven !== null}
        title="This suggestion was helpful"
        aria-label="Thumbs up - helpful suggestion"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3" />
        </svg>
      </button>
      <button
        className={`feedback-btn thumbs-down ${feedbackGiven === "negative" ? "active" : ""}`}
        onClick={() => onFeedback("negative")}
        disabled={isSubmitting || feedbackGiven !== null}
        title="This suggestion wasn't helpful"
        aria-label="Thumbs down - not helpful suggestion"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17" />
        </svg>
      </button>
    </div>
  );
}

export default SmartDailyPlan;
