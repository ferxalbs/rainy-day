/**
 * SmartDailyPlan Component
 *
 * AI-powered daily plan component that displays focus blocks, quick wins,
 * meetings, and defer suggestions generated by the AI.
 * Uses Tailwind CSS v4 for styling.
 *
 * Requirements: 1.6, 1.7, 5.1, 5.5, 6.4, 8.4, 8.5
 * Email Actions Requirements: 1.1, 2.1, 3.1, 3.4
 */

import { useState, useEffect, useCallback } from "react";
import { useDailyPlan } from "../../hooks/useDailyPlan";
import { useEmailActions } from "../../hooks/useEmailActions";
import { REGENERATE_PLAN_EVENT } from "../../hooks/useKeyboardShortcuts";
import { EmailActionBar } from "./EmailActionBar";
import type { PlanTask, ItemFeedbackType } from "../../services/backend/plan";

interface SmartDailyPlanProps {
  onTaskComplete?: (taskId: string) => void;
  onTaskCreate?: (title: string) => void;
}

/**
 * Notification state for displaying success/error messages
 * Requirements: 3.4
 */
interface NotificationState {
  type: "success" | "error";
  message: string;
  id: number;
  /** Optional action for retry */
  action?: {
    label: string;
    onClick: () => void;
  };
}

/**
 * Optimistic state for email items
 * Requirements: 6.1, 6.2, 6.3, 6.4
 */
interface OptimisticEmailState {
  archived: boolean;
  markedRead: boolean;
}

export function SmartDailyPlan({
  onTaskComplete,
  onTaskCreate: _onTaskCreate,
}: SmartDailyPlanProps) {
  void _onTaskCreate;
  const {
    plan,
    isLoading,
    isGenerating,
    error,
    regenerate,
    submitItemFeedback,
  } = useDailyPlan();

  // Email actions hook for archive, mark-read, convert-to-task
  const {
    archiveEmail,
    markAsRead,
    convertToTask,
    loadingStates: emailLoadingStates,
    retryLastAction: _retryLastAction,
  } = useEmailActions();

  // Notification state for success/error messages
  // Requirements: 3.4
  const [notifications, setNotifications] = useState<NotificationState[]>([]);

  // Optimistic state for email items (keyed by email ID)
  // Requirements: 6.1, 6.2, 6.3, 6.4
  const [optimisticStates, setOptimisticStates] = useState<
    Record<string, OptimisticEmailState>
  >({});

  /**
   * Dismiss a notification
   */
  const dismissNotification = useCallback((id: number) => {
    setNotifications((prev) => prev.filter((n) => n.id !== id));
  }, []);

  /**
   * Show a notification message
   * Requirements: 3.4
   */
  const showNotification = useCallback(
    (
      type: "success" | "error",
      message: string,
      action?: { label: string; onClick: () => void }
    ) => {
      const id = Date.now();
      setNotifications((prev) => [...prev, { type, message, id, action }]);
      // Auto-dismiss after 5 seconds for success, 8 seconds for errors (to allow retry)
      const dismissTime = type === "success" ? 4000 : 6000;
      setTimeout(() => {
        setNotifications((prev) => prev.filter((n) => n.id !== id));
      }, dismissTime);
    },
    []
  );

  /**
   * Set optimistic state for an email
   */
  const setOptimisticState = useCallback(
    (emailId: string, state: Partial<OptimisticEmailState>) => {
      setOptimisticStates((prev) => ({
        ...prev,
        [emailId]: {
          archived: prev[emailId]?.archived ?? false,
          markedRead: prev[emailId]?.markedRead ?? false,
          ...state,
        },
      }));
    },
    []
  );

  /**
   * Rollback optimistic state for an email
   * Requirements: 6.2, 6.4
   */
  const rollbackOptimisticState = useCallback(
    (emailId: string, state: Partial<OptimisticEmailState>) => {
      setOptimisticStates((prev) => {
        const current = prev[emailId];
        if (!current) return prev;

        const updated = { ...current };
        if (state.archived !== undefined) updated.archived = false;
        if (state.markedRead !== undefined) updated.markedRead = false;

        // If both are false, remove the entry
        if (!updated.archived && !updated.markedRead) {
          const { [emailId]: _, ...rest } = prev;
          return rest;
        }

        return { ...prev, [emailId]: updated };
      });
    },
    []
  );

  /**
   * Handle archive email action with optimistic update
   * Requirements: 1.1, 1.3, 6.1, 6.2
   */
  const handleArchiveEmail = useCallback(
    async (emailId: string) => {
      // Optimistic update: immediately mark as archived
      setOptimisticState(emailId, { archived: true });

      const result = await archiveEmail(emailId);
      if (result.success) {
        showNotification("success", "üì• Email archived successfully");
      } else {
        // Rollback on failure
        rollbackOptimisticState(emailId, { archived: true });
        showNotification("error", result.message || "Failed to archive email", {
          label: "Retry",
          onClick: () => handleArchiveEmail(emailId),
        });
      }
    },
    [
      archiveEmail,
      showNotification,
      setOptimisticState,
      rollbackOptimisticState,
    ]
  );

  /**
   * Handle mark email as read action with optimistic update
   * Requirements: 2.1, 2.3, 6.3, 6.4
   */
  const handleMarkAsRead = useCallback(
    async (emailId: string) => {
      // Optimistic update: immediately mark as read
      setOptimisticState(emailId, { markedRead: true });

      const result = await markAsRead(emailId);
      if (result.success) {
        showNotification("success", "‚úì Email marked as read");
      } else {
        // Rollback on failure
        rollbackOptimisticState(emailId, { markedRead: true });
        showNotification(
          "error",
          result.message || "Failed to mark email as read",
          {
            label: "Retry",
            onClick: () => handleMarkAsRead(emailId),
          }
        );
      }
    },
    [markAsRead, showNotification, setOptimisticState, rollbackOptimisticState]
  );

  /**
   * Handle convert email to task action
   * Requirements: 3.1, 3.4, 3.5
   */
  const handleConvertToTask = useCallback(
    async (emailId: string) => {
      const result = await convertToTask(emailId);
      if (result.success && result.data) {
        showNotification(
          "success",
          `‚úÖ Task created: "${result.data.task_title}"`
        );
      } else {
        showNotification(
          "error",
          result.message || "Failed to convert email to task",
          {
            label: "Retry",
            onClick: () => handleConvertToTask(emailId),
          }
        );
      }
    },
    [convertToTask, showNotification]
  );

  /**
   * Filter tasks based on optimistic state (hide archived emails)
   * Requirements: 6.1
   */
  const filterOptimisticallyArchivedTasks = useCallback(
    (tasks: PlanTask[]) => {
      return tasks.filter((task) => {
        // Only filter email items
        if (task.type !== "email" && task.source_type !== "email") return true;
        // Check if optimistically archived
        const emailId = task.source_id;
        if (!emailId) return true;
        return !optimisticStates[emailId]?.archived;
      });
    },
    [optimisticStates]
  );

  /**
   * Check if an email is optimistically marked as read
   * Requirements: 6.3
   */
  const isOptimisticallyRead = useCallback(
    (emailId: string | undefined) => {
      if (!emailId) return false;
      return optimisticStates[emailId]?.markedRead ?? false;
    },
    [optimisticStates]
  );

  // Listen for keyboard shortcut to regenerate plan (Cmd+R)
  useEffect(() => {
    const handleRegenerate = () => {
      if (!isGenerating) {
        regenerate();
      }
    };

    window.addEventListener(REGENERATE_PLAN_EVENT, handleRegenerate);
    return () =>
      window.removeEventListener(REGENERATE_PLAN_EVENT, handleRegenerate);
  }, [regenerate, isGenerating]);

  const formatSuggestedTime = (time?: string) => {
    if (!time) return null;

    // If already readable format, return as is
    if (/^\d{1,2}:\d{2}\s?(AM|PM|am|pm)?$/i.test(time)) {
      return time;
    }

    // Descriptive times
    if (/^(morning|afternoon|evening|noon|early|late)/i.test(time)) {
      return time.charAt(0).toUpperCase() + time.slice(1);
    }

    // Try ISO parse
    try {
      const date = new Date(time);
      if (!isNaN(date.getTime())) {
        return date.toLocaleTimeString("en-US", {
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
        });
      }
    } catch {
      // Parsing failed
    }

    return time;
  };

  const getPriorityClasses = (priority: PlanTask["priority"]) => {
    switch (priority) {
      case "high":
        return "bg-destructive/20 text-destructive border-destructive/80";
      case "medium":
        return "bg-amber-500/20 text-amber-500 border-amber-500/20";
      case "low":
        return "bg-green-500/20 text-green-500 border-green-500/20";
      default:
        return "bg-muted text-muted-foreground";
    }
  };

  const getTypeIcon = (type: PlanTask["type"]) => {
    switch (type) {
      case "focus":
        return "üéØ";
      case "task":
        return "‚úÖ";
      case "email":
        return "üìß";
      case "meeting":
        return "üìÖ";
      case "break":
        return "‚òï";
      default:
        return "üìã";
    }
  };

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[50vh] gap-4 text-muted-foreground">
        <div className="w-8 h-8 border-4 border-muted/30 border-t-primary rounded-full animate-spin" />
        <p>Loading your AI-powered plan...</p>
      </div>
    );
  }

  if (error && !plan) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[50vh] gap-4 text-muted-foreground">
        <p className="text-destructive">{error}</p>
        <button
          onClick={regenerate}
          className="px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors"
        >
          Generate Plan
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Notifications - Requirements: 3.4 */}
      {notifications.length > 0 && (
        <div className="fixed top-4 right-4 z-50 space-y-2 max-w-sm">
          {notifications.map((notification) => (
            <div
              key={notification.id}
              className={`px-4 py-3 rounded-lg shadow-lg backdrop-blur-md border transition-all animate-in slide-in-from-right-5 ${
                notification.type === "success"
                  ? "bg-green-500/90 text-white border-green-400/50"
                  : "bg-destructive/90 text-destructive-foreground border-destructive/50"
              }`}
            >
              <div className="flex items-start gap-2">
                <span className="text-lg flex-shrink-0">
                  {notification.type === "success" ? "‚úì" : "‚úï"}
                </span>
                <div className="flex-1 min-w-0">
                  <span className="text-sm font-medium block">
                    {notification.message}
                  </span>
                  {notification.action && (
                    <button
                      onClick={() => {
                        dismissNotification(notification.id);
                        notification.action?.onClick();
                      }}
                      className="mt-2 text-xs font-semibold underline underline-offset-2 hover:no-underline opacity-90 hover:opacity-100"
                    >
                      {notification.action.label}
                    </button>
                  )}
                </div>
                <button
                  onClick={() => dismissNotification(notification.id)}
                  className="flex-shrink-0 p-0.5 rounded hover:bg-white/20 transition-colors"
                  aria-label="Dismiss notification"
                >
                  <svg
                    width="14"
                    height="14"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                  >
                    <path d="M18 6L6 18M6 6l12 12" />
                  </svg>
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
      {/* Summary Card */}
      {plan && (plan.summary || plan.energy_tip) && (
        <section className="p-5 rounded-2xl bg-gradient-to-br from-primary/10 to-purple-500/10 border-2 border-border/50 backdrop-blur-3xl shadow-xl shadow-primary/5">
          {plan.summary && (
            <p className="text-foreground/90 leading-relaxed mb-4 text-base">
              {plan.summary}
            </p>
          )}
          {plan.energy_tip && (
            <div className="flex items-start gap-3 p-3 rounded-xl bg-card/30 text-sm text-foreground/80 border border-border/30">
              <span className="text-lg">üí°</span>
              <span className="leading-snug pt-0.5">{plan.energy_tip}</span>
            </div>
          )}
        </section>
      )}

      {/* Focus Blocks */}
      <Section
        title="Focus Blocks"
        icon="üéØ"
        count={
          plan ? filterOptimisticallyArchivedTasks(plan.focus_blocks).length : 0
        }
      >
        {!plan ||
        filterOptimisticallyArchivedTasks(plan.focus_blocks).length === 0 ? (
          <EmptyState>No focus blocks scheduled</EmptyState>
        ) : (
          <div className="space-y-3">
            {filterOptimisticallyArchivedTasks(plan.focus_blocks).map(
              (task) => (
                <TaskCard
                  key={task.id}
                  task={task}
                  itemType="focus_block"
                  onComplete={onTaskComplete}
                  onFeedback={submitItemFeedback}
                  formatTime={formatSuggestedTime}
                  getPriorityClasses={getPriorityClasses}
                  getTypeIcon={getTypeIcon}
                  onArchiveEmail={handleArchiveEmail}
                  onMarkAsRead={handleMarkAsRead}
                  onConvertToTask={handleConvertToTask}
                  emailLoadingState={
                    task.source_id
                      ? emailLoadingStates[task.source_id]
                      : undefined
                  }
                  isOptimisticallyRead={isOptimisticallyRead(task.source_id)}
                />
              )
            )}
          </div>
        )}
      </Section>

      {/* Quick Wins */}
      <Section
        title="Quick Wins"
        icon="‚ö°"
        count={
          plan ? filterOptimisticallyArchivedTasks(plan.quick_wins).length : 0
        }
      >
        {!plan ||
        filterOptimisticallyArchivedTasks(plan.quick_wins).length === 0 ? (
          <EmptyState>No quick wins available</EmptyState>
        ) : (
          <div className="space-y-3">
            {filterOptimisticallyArchivedTasks(plan.quick_wins).map((task) => (
              <TaskCard
                key={task.id}
                task={task}
                itemType="quick_win"
                onComplete={onTaskComplete}
                onFeedback={submitItemFeedback}
                formatTime={formatSuggestedTime}
                getPriorityClasses={getPriorityClasses}
                getTypeIcon={getTypeIcon}
                onArchiveEmail={handleArchiveEmail}
                onMarkAsRead={handleMarkAsRead}
                onConvertToTask={handleConvertToTask}
                emailLoadingState={
                  task.source_id
                    ? emailLoadingStates[task.source_id]
                    : undefined
                }
                isOptimisticallyRead={isOptimisticallyRead(task.source_id)}
              />
            ))}
          </div>
        )}
      </Section>

      {/* Meetings */}
      <Section title="Meetings" icon="üìÖ" count={plan?.meetings?.length ?? 0}>
        {!plan || plan.meetings.length === 0 ? (
          <EmptyState>No meetings scheduled</EmptyState>
        ) : (
          <div className="space-y-3">
            {plan.meetings.map((meeting) => (
              <MeetingCard
                key={meeting.id}
                meeting={meeting}
                onFeedback={submitItemFeedback}
                formatTime={formatSuggestedTime}
              />
            ))}
          </div>
        )}
      </Section>

      {/* Defer Suggestions */}
      {plan && plan.defer_suggestions.length > 0 && (
        <Section
          title="Consider Deferring"
          icon="üìå"
          count={plan.defer_suggestions.length}
        >
          <div className="space-y-2">
            {plan.defer_suggestions.map((suggestion, index) => (
              <DeferCard
                key={index}
                suggestion={suggestion}
                index={index}
                onFeedback={submitItemFeedback}
              />
            ))}
          </div>
        </Section>
      )}

      {/* No Plan State */}
      {!plan && !error && (
        <section className="p-12 rounded-2xl bg-card/30 border-2 border-border/30 backdrop-blur-2xl text-center shadow-xl">
          <p className="text-muted-foreground mb-6 text-lg">
            No plan generated yet for today.
          </p>
          <button
            onClick={regenerate}
            disabled={isGenerating}
            className="px-8 py-3 bg-primary text-primary-foreground rounded-xl font-medium
                         hover:bg-primary/90 transition-all disabled:opacity-50 shadow-lg shadow-primary/20"
          >
            {isGenerating ? "Generating..." : "Generate AI Plan"}
          </button>
        </section>
      )}
    </div>
  );
}

// Section Component
function Section({
  title,
  icon,
  count,
  children,
}: {
  title: string;
  icon: string;
  count: number;
  children: React.ReactNode;
}) {
  return (
    <section className="p-5 rounded-2xl mica-blur-vibrant border-2 border-border/50 shadow-xl shadow-primary/5 transition-all">
      <h2 className="flex items-center gap-3 text-lg font-semibold text-foreground mb-4 opacity-90">
        <span className="text-2xl filter drop-shadow-sm">{icon}</span>
        {title}
        {count > 0 && (
          <span className="ml-auto text-xs font-semibold text-muted-foreground bg-muted/20 border-2 border-border/10 px-2.5 py-1 rounded-full backdrop-blur-md">
            {count}
          </span>
        )}
      </h2>
      {children}
    </section>
  );
}

// Empty State
function EmptyState({ children }: { children: React.ReactNode }) {
  return (
    <p className="text-center text-muted-foreground text-sm py-4">{children}</p>
  );
}

// Task Card
interface TaskCardProps {
  task: PlanTask;
  itemType: "focus_block" | "quick_win" | "meeting" | "defer";
  onComplete?: (taskId: string) => void;
  onFeedback?: (
    itemId: string,
    itemTitle: string,
    feedbackType: ItemFeedbackType,
    itemType: "focus_block" | "quick_win" | "meeting" | "defer"
  ) => Promise<boolean>;
  formatTime: (time?: string) => string | null;
  getPriorityClasses: (priority: PlanTask["priority"]) => string;
  getTypeIcon: (type: PlanTask["type"]) => string;
  // Email action handlers
  onArchiveEmail?: (emailId: string) => Promise<void>;
  onMarkAsRead?: (emailId: string) => Promise<void>;
  onConvertToTask?: (emailId: string) => Promise<void>;
  emailLoadingState?: {
    archive: boolean;
    markRead: boolean;
    toTask: boolean;
  };
  // Optimistic state for read status
  isOptimisticallyRead?: boolean;
}

function TaskCard({
  task,
  itemType,
  onComplete,
  onFeedback,
  formatTime,
  getPriorityClasses,
  getTypeIcon,
  onArchiveEmail,
  onMarkAsRead,
  onConvertToTask,
  emailLoadingState,
  isOptimisticallyRead = false,
}: TaskCardProps) {
  const [feedbackGiven, setFeedbackGiven] = useState<ItemFeedbackType | null>(
    null
  );
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleComplete = () => {
    if (task.source_id && onComplete) {
      onComplete(task.source_id);
    }
  };

  const handleFeedback = async (type: ItemFeedbackType) => {
    if (!onFeedback || isSubmitting) return;

    setIsSubmitting(true);
    const success = await onFeedback(task.id, task.title, type, itemType);
    if (success) {
      setFeedbackGiven(type);
    }
    setIsSubmitting(false);
  };

  // Check if this is an email item
  const isEmail = task.type === "email" || task.source_type === "email";
  // For emails, check optimistic read state (if optimistically read, show as read)
  // Requirements: 6.3
  const isUnread = !isOptimisticallyRead;

  // Apply read styling for optimistically read emails
  // Requirements: 6.3
  const readStyling = isEmail && isOptimisticallyRead ? "opacity-60" : "";

  return (
    <div
      className={`flex items-start gap-4 p-4 rounded-xl bg-card/20 hover:bg-card/30 border border-transparent hover:border-border/60 transition-all duration-300 group ${readStyling}`}
    >
      {task.source_type === "task" && (
        <input
          type="checkbox"
          onChange={handleComplete}
          className="mt-1 w-4 h-4 rounded-md border-muted-foreground/40 accent-primary focus:ring-primary/20"
          title="Mark as complete"
        />
      )}
      <div className="flex-1 min-w-0">
        <div className="flex flex-wrap items-center gap-2 mb-1.5">
          <span className="filter drop-shadow-sm opacity-90">
            {getTypeIcon(task.type)}
          </span>
          <span
            className={`text-foreground font-medium text-base tracking-tight ${
              isEmail && isOptimisticallyRead ? "font-normal" : ""
            }`}
          >
            {task.title}
          </span>
          <span
            className={`text-[10px] px-2 py-0.5 rounded-full uppercase border font-bold tracking-wider ${getPriorityClasses(
              task.priority
            )}`}
          >
            {task.priority}
          </span>
          {/* Show "Read" badge for optimistically read emails */}
          {isEmail && isOptimisticallyRead && (
            <span className="text-[10px] px-2 py-0.5 rounded-full bg-muted/30 text-muted-foreground border border-muted/50">
              Read
            </span>
          )}
        </div>
        <div className="flex flex-wrap items-center gap-4 text-xs text-muted-foreground/80 font-medium">
          {formatTime(task.suggested_time) && (
            <span className="flex items-center gap-1.5">
              <span>üïê</span>
              {formatTime(task.suggested_time)}
            </span>
          )}
          {task.duration_minutes > 0 && (
            <span className="flex items-center gap-1.5">
              <span>‚è±Ô∏è</span>
              {task.duration_minutes}min
            </span>
          )}
        </div>
        {task.context && (
          <p className="mt-2 text-sm text-foreground/60 italic leading-relaxed">
            {task.context}
          </p>
        )}
      </div>

      {/* Email Action Bar - shown for email items */}
      {isEmail && task.source_id && (
        <div className="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity">
          <EmailActionBar
            email={{
              id: task.source_id,
              subject: task.title,
              isUnread: isUnread,
            }}
            onArchive={() => onArchiveEmail?.(task.source_id!)}
            onMarkRead={() => onMarkAsRead?.(task.source_id!)}
            onConvertToTask={() => onConvertToTask?.(task.source_id!)}
            loadingState={emailLoadingState}
            compact
          />
        </div>
      )}

      <FeedbackButtons
        feedbackGiven={feedbackGiven}
        isSubmitting={isSubmitting}
        onFeedback={handleFeedback}
      />
    </div>
  );
}

// Meeting Card
interface MeetingCardProps {
  meeting: PlanTask;
  onFeedback?: (
    itemId: string,
    itemTitle: string,
    feedbackType: ItemFeedbackType,
    itemType: "focus_block" | "quick_win" | "meeting" | "defer"
  ) => Promise<boolean>;
  formatTime: (time?: string) => string | null;
}

function MeetingCard({ meeting, onFeedback, formatTime }: MeetingCardProps) {
  const [feedbackGiven, setFeedbackGiven] = useState<ItemFeedbackType | null>(
    null
  );
  const [isSubmitting, setIsSubmitting] = useState(false);

  const isStartingSoon = () => {
    if (!meeting.suggested_time) return false;
    try {
      const meetingTime = new Date(meeting.suggested_time);
      const now = new Date();
      const diffMinutes = (meetingTime.getTime() - now.getTime()) / (1000 * 60);
      return diffMinutes >= 0 && diffMinutes <= 15;
    } catch {
      return false;
    }
  };

  const handleFeedback = async (type: ItemFeedbackType) => {
    if (!onFeedback || isSubmitting) return;

    setIsSubmitting(true);
    const success = await onFeedback(
      meeting.id,
      meeting.title,
      type,
      "meeting"
    );
    if (success) {
      setFeedbackGiven(type);
    }
    setIsSubmitting(false);
  };

  return (
    <div
      className={`flex items-start gap-4 p-4 rounded-xl transition-all border
                    ${
                      isStartingSoon()
                        ? "bg-primary/10 border-primary shadow-lg shadow-primary/10"
                        : "bg-card/20 hover:bg-card/30 border-transparent hover:border-border/60"
                    }`}
    >
      <div className="text-primary text-sm font-semibold min-w-[70px] uppercase tracking-wide">
        {formatTime(meeting.suggested_time) || "TBD"}
      </div>
      <div className="flex-1 min-w-0">
        <span className="text-foreground font-medium text-base tracking-tight block">
          {meeting.title}
        </span>
        {meeting.duration_minutes > 0 && (
          <span className="inline-block mt-1 text-xs text-muted-foreground font-medium bg-muted/20 px-2 py-0.5 rounded-md">
            {meeting.duration_minutes} min
          </span>
        )}
        {meeting.context && (
          <p className="text-sm text-foreground/60 mt-1.5 leading-relaxed">
            {meeting.context}
          </p>
        )}
      </div>
      <FeedbackButtons
        feedbackGiven={feedbackGiven}
        isSubmitting={isSubmitting}
        onFeedback={handleFeedback}
      />
    </div>
  );
}

// Defer Card
interface DeferCardProps {
  suggestion: string | PlanTask;
  index: number;
  onFeedback?: (
    itemId: string,
    itemTitle: string,
    feedbackType: ItemFeedbackType,
    itemType: "focus_block" | "quick_win" | "meeting" | "defer"
  ) => Promise<boolean>;
}

function DeferCard({ suggestion, index, onFeedback }: DeferCardProps) {
  const [feedbackGiven, setFeedbackGiven] = useState<ItemFeedbackType | null>(
    null
  );
  const [isSubmitting, setIsSubmitting] = useState(false);

  const suggestionText =
    typeof suggestion === "string" ? suggestion : suggestion.title;
  const suggestionId =
    typeof suggestion === "string" ? `defer-${index}` : suggestion.id;

  const handleFeedback = async (type: ItemFeedbackType) => {
    if (!onFeedback || isSubmitting) return;

    setIsSubmitting(true);
    const success = await onFeedback(
      suggestionId,
      suggestionText,
      type,
      "defer"
    );
    if (success) {
      setFeedbackGiven(type);
    }
    setIsSubmitting(false);
  };

  return (
    <div className="flex items-center gap-2 p-2 rounded-lg bg-card/30 border-l-2 border-muted-foreground/30">
      <span className="flex-1 text-sm text-muted-foreground">
        {suggestionText}
      </span>
      <FeedbackButtons
        feedbackGiven={feedbackGiven}
        isSubmitting={isSubmitting}
        onFeedback={handleFeedback}
      />
    </div>
  );
}

// Feedback Buttons
interface FeedbackButtonsProps {
  feedbackGiven: ItemFeedbackType | null;
  isSubmitting: boolean;
  onFeedback: (type: ItemFeedbackType) => void;
}

function FeedbackButtons({
  feedbackGiven,
  isSubmitting,
  onFeedback,
}: FeedbackButtonsProps) {
  return (
    <div className="flex gap-1 flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity">
      <button
        className={`p-1.5 rounded transition-colors ${
          feedbackGiven === "positive"
            ? "bg-green-500/10 text-green-500"
            : "text-muted-foreground hover:text-foreground hover:bg-muted"
        }`}
        onClick={() => onFeedback("positive")}
        disabled={isSubmitting || feedbackGiven !== null}
        title="Helpful"
      >
        <svg
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
        >
          <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3" />
        </svg>
      </button>
      <button
        className={`p-1.5 rounded transition-colors ${
          feedbackGiven === "negative"
            ? "bg-destructive/10 text-destructive"
            : "text-muted-foreground hover:text-foreground hover:bg-muted"
        }`}
        onClick={() => onFeedback("negative")}
        disabled={isSubmitting || feedbackGiven !== null}
        title="Not helpful"
      >
        <svg
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
        >
          <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17" />
        </svg>
      </button>
    </div>
  );
}
